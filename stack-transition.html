<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js" integrity="sha512-vc58qvvBdrDR4etbxMdlTt4GBQk1qjvyORR2nrsPsFPyrs+/u5c3+1Ct6upOgdZoIl7eq6k3a1UPDSNAQi/32A==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3.1.0/dist/d3-scale-chromatic.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-ease@3.0.1/dist/d3-ease.min.js"></script>
  </head>
  <body onload="main()">
  </body>
  <script>
    function stackTransition(data) {
      const total = d3.sum(data)
      const scales = d3.stack()
        .keys([...data.keys()])
        ([data])
        .map(([[start, end]]) => d3.scaleLinear([start/total, end/total], [0, 1]))

      return function (element) {
        const ease = element.ease()
        element.delay(0)
          .duration(element.duration())
          .easeVarying((_, i, slices) => t => {
            let variation = scales[i](ease(t))
            if (variation <= 0 && i > 0) return 0
            if (variation > 1 && i < slices.length - 1) return 1
            return variation
          })
      }
    }
    function main() {
      function visualCompare ({ width, height, ...props }, action) {
        const easers = [
          'easeLinear',
          'easePolyIn',
          'easePolyOut',
          'easePolyInOut',
          'easeQuadIn',
          'easeQuadOut',
          'easeQuadInOut',
          'easeCubicIn',
          'easeCubicOut',
          'easeCubicInOut',
          'easeSinIn',
          'easeSinOut',
          'easeSinInOut',
          'easeExpIn',
          'easeExpOut',
          'easeExpInOut',
          'easeCircleIn',
          'easeCircleOut',
          'easeCircleInOut',
          'easeElasticIn',
          'easeElasticOut',
          'easeElasticInOut',
          'easeBackIn',
          'easeBackOut',
          'easeBackInOut',
          'easeBounceIn',
          'easeBounceOut',
          'easeBounceInOut'
        ]
        easers.forEach(ease => {
          const svg = d3.select('body')
            .append('svg')
            .attr('width', width)
            .attr('height', height);
          svg.append('text')
            .attr('y', 15)
            .attr('x', width / 2)
            .attr('text-anchor', 'middle')
            .text(ease)
          svg.append('rect')
            .attr('width', width - 1)
            .attr('height', height - 1)
            .attr('stroke', 'black')
            .attr('fill-opacity', 0)
          action({ svg, width, height, ease, ...props })
        })
      }
      visualCompare({ width: 140, height: 280, radius: 60 }, ({ svg, width, height, radius, ease }) => {
        singleSlicePie({ svg, fill: d3.scaleOrdinal(d3.schemeAccent), width, height, radius, ease: d3[ease], y: height / 4 + 10 })
        stackAnimatedPie({ svg, fill: d3.scaleOrdinal(d3.schemeAccent), width, height, radius, ease: d3[ease], y: height * 3 / 4 })
      })
      visualCompare({ width: 250, height: 140, top: 40 }, ({ svg, width, ease, top }) => {
        singleBar({ svg, fill: d3.scaleOrdinal(d3.schemeAccent), width, height: 100, ease: d3[ease], x: width / 4 - 25, top })
        stackAnimatedBar({ svg, fill: d3.scaleOrdinal(d3.schemeAccent), width, height: 100, ease: d3[ease], x: width * 3 / 4 - 25, top })
      })
    }
    function singleSlicePie({ svg, width, height, radius, ease, fill, y }) {
      const data = [54]
      const pie = d3.pie();
      const arcs = pie(data);
      svg.append('g')
        .attr('transform', `translate(${width / 2}, ${y})`)
        .selectAll('.slice')
        .data(arcs)
        .enter()
        .append('path')
        .classed('slice', true)
        .attr('d', v => d3.arc()
          .innerRadius(0)
          .outerRadius(radius)
          .startAngle(0)
          .endAngle(0)()
        )
        .attr('fill', fill)
        .attr('stroke', 'black')
        .attr('stroke-width', '1px')
        .transition()
        .delay((v, i) => i * 1000)
        .duration(5000)
        .ease(ease)
        .attrTween('d', v => t => d3.arc()
          .innerRadius(0)
          .outerRadius(radius)
          .startAngle(v.startAngle)
          .endAngle(v.endAngle * t + v.startAngle * (1 - t))()
        );
    }
    function stackAnimatedPie({ svg, width, height, radius, ease, fill, y }) {
      const data = [21, 13, 8, 5, 3, 2, 1, 1];
      const pie = d3.pie();
      const arcs = pie(data);

      svg.append('g')
        .attr('transform', `translate(${width / 2}, ${y})`)
        .selectAll('.slice')
        .data(arcs)
        .enter()
        .append('path')
        .classed('slice', true)
        .attr('d', v => d3.arc()
          .innerRadius(0)
          .outerRadius(radius)
          .startAngle(0)
          .endAngle(0)()
        )
        .attr('fill', fill)
        .attr('stroke', 'black')
        .attr('stroke-width', '1px')
        .transition()
        .duration(5000)
        .ease(ease)
        .call(stackTransition(data))
        .attrTween('opacity', (v, i) => t => {
          if (t <= 0 && i > 0) return 0
          if (t > 0) return 1
        })
        .attrTween('d', v => t => d3.arc()
          .innerRadius(0)
          .outerRadius(radius)
          .startAngle(v.startAngle)
          .endAngle(v.endAngle * t + v.startAngle * (1 - t))()
        );
    }
    function singleBar({ svg, width, height, ease, fill, top, x }) {
      const data = [54]
      svg.append('g')
        .selectAll('.element')
        .data(data)
        .enter()
        .append('rect')
        .attr('width', 25)
        .attr('y', height + top)
        .attr('x', x)
        .attr('height', 0)
        .attr('fill', fill)
        .attr('stroke', 'black')
        .attr('stroke-width', '1px')
        .transition()
        .duration(5000)
        .ease(ease)
        .attr('y', top)
        .attr('height', height);
    }
    function stackAnimatedBar({ svg, width, height, ease, fill, top, x }) {
      const data = [21, 13, 8, 5, 3, 2, 1, 1]
      const stack = d3.stack()
        .keys([...data.keys()])
        ([Object.fromEntries(data.map((v,i)=>[i,v]))])
      const yScale = d3.scaleLinear([0, d3.sum(data)], [0, height])
      svg.append('g')
        .selectAll('rect')
        .data(stack)
        .enter()
        .append('rect')
        .attr('width', 25)
        .attr('x', x)
        .attr('y', v => height + top - yScale(v[0][0]))
        .attr('height', 0)
        .attr('fill', fill)
        .attr('stroke', 'black')
        .attr('stroke-width', '1px')
        .transition()
        .duration(5000)
        .ease(ease)
        .call(stackTransition(data))
        .attr('y', v => {
          return top + height - yScale(v[0][1])
        })
        .attr('height', v => {
          return yScale(v[0].data[v.index])
        })
    }
  </script>
</html>